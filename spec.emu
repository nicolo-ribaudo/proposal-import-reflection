<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./spec.js"></script>
<pre class="metadata">
title: Source Phase Imports
stage: 2
contributors: Luca Casonato, Guy Bedford, Nicol√≤ Ribaudo
</pre>

<emu-clause id="sec-ecmascript-language-expressions" number="13">
  <h1>ECMAScript Language: Expressions</h1>

  <emu-clause id="sec-import-calls" number="3.10">
    <h1>Import Calls</h1>

    <emu-clause id="sec-import-call-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>

      <emu-grammar>ImportCall : `import` `(` AssignmentExpression `)`</emu-grammar>
      <emu-alg>
        1. <del>Let _referrer_ be GetActiveScriptOrModule().</del>
        1. <del>If _referrer_ is *null*, set _referrer_ to the current Realm Record.</del>
        1. <del>Let _argRef_ be ? Evaluation of |AssignmentExpression|.</del>
        1. <del>Let _specifier_ be ? GetValue(_argRef_).</del>
        1. <del>Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).</del>
        1. <del>Let _specifierString_ be Completion(ToString(_specifier_)).</del>
        1. <del>IfAbruptRejectPromise(_specifierString_, _promiseCapability_).</del>
        1. <del>Perform HostLoadImportedModule(_referrer_, _specifierString_, ~empty~, _promiseCapability_).</del>
        1. <del>Return _promiseCapability_.[[Promise]].</del>
        1. <ins>Let _specifierRef_ be the result of evaluating |AssignmentExpression|.</ins>
        1. <ins>Let _specifier_ be ? GetValue(_specifierRef_).</ins>
        1. <ins>Return EvaluateImportCall(_specifier_, *undefined*).</ins>
      </emu-alg>

      <emu-grammar><ins>ImportCall : `import` `(` AssignmentExpression `,` AssignmentExpression `)`</ins></emu-grammar>
      <emu-alg>
        1. <ins>Let _specifierRef_ be the result of evaluating the first |AssignmentExpression|.</ins>
        1. <ins>Let _specifier_ be ? GetValue(_specifierRef_).</ins>
        1. <ins>Let _optionsRef_ be the result of evaluating the second |AssignmentExpression|.</ins>
        1. <ins>Let _options_ be ? GetValue(_optionsRef_).</ins>
        1. <ins>Return EvaluateImportCall(_specifier_, _options_).</ins>
      </emu-alg>

      <emu-clause id="sec-evaluate-import-call" type="abstract operation">
        <h1><ins>EvaluateImportCall ( _specifier_ , _options_ )</ins></h1>
        <dl class="header"></dl>
        <emu-alg>
          1. Let _referrer_ be GetActiveScriptOrModule().
          1. If _referrer_ is *null*, set _referrer_ to the current Realm Record.
          1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
          1. Let _specifierString_ be Completion(ToString(_specifier_)).
          1. IfAbruptRejectPromise(_specifierString_, _promiseCapability_).
          1. Let _phase_ be ~evaluation~.
          1. If _options_ is not *undefined*, then
            1. If Type(_options_) is not Object,
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; a newly created *TypeError* object &raquo;).
              1. Return _promiseCapability_.[[Promise]].
            1. Let _phaseOption_ be Get(_options_, *"phase"*).
            1. IfAbruptRejectPromise(_phaseOption_, _promiseCapability_).
            1. If _phaseOption_ is not *undefined*,
              1. If Type(_phaseOption_) is not *"source"*, then
                1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; a newly created *TypeError* object &raquo;).
                1. Return _promiseCapability_.[[Promise]].
              1. Set _phase_ to ~source~.
          1. Let _moduleRequest_ be a new ModuleRequest Record { [[Specifier]]: _specifierString_, [[Phase]]: _phase_ }.
          1. Let _state_ be the DynamicImportState Record { [[PromiseCapability]]: _promiseCapability_, [[Phase]]: _phase_ }.
          1. Perform HostLoadImportedModule(_referrer_, _moduleRequest_, ~empty~, _state_).
          1. Return _promiseCapability_.[[Promise]].
        </emu-alg>
      </emu-clause>

      <p><ins>A <dfn id="dynamicimportstate-record" variants="DynamicImportState Records">DynamicImportState Record</dfn> is a Record that contains information about the loading process of a module graph. It's used to continue loading after a call to HostLoadImportedModule. Each DynamicImportState Record has the fields defined in <emu-xref href="#table-dynamicimportstate-record-fields"></emu-xref>:</ins></p>
      <emu-table id="table-dynamicimportstate-record-fields" caption="DynamicImportState Record Fields">
        <table>
          <tr>
            <th>
              Field Name
            </th>
            <th>
              Value Type
            </th>
            <th>
              Meaning
            </th>
          </tr>
          <tr>
            <td>
              <ins>[[PromiseCapability]]</ins>
            </td>
            <td>
              <ins>a PromiseCapability Record</ins>
            </td>
            <td>
              <ins>The promise to resolve when the dynamic import finishes.</ins>
            </td>
          </tr>
          <tr>
            <td>
              <ins>[[Phase]]</ins>
            </td>
            <td>
              <ins>~source~ or ~evaluation~</ins>
            </td>
            <td>
              <ins>The target import phase. It's ~source~ when using the `phase: "source"` option, and ~evaluation~ otherwise.</ins>
            </td>
          </tr>
        </table>
      </emu-table>

      <emu-clause id="sec-ContinueDynamicImport" type="abstract operation">
        <h1>
          ContinueDynamicImport (
            <del>_promiseCapability_: a PromiseCapability Record,</del>
            <ins>_state_: a DynamicImportState Record,</ins>
            _moduleCompletion_: either a normal completion containing a Module Record or a throw completion,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It completes the process of a dynamic import originally started by an <emu-xref href="#sec-import-calls">`import()`</emu-xref> call, resolving or rejecting the promise returned by that call as appropriate.</dd>
        </dl>
        <emu-alg>
          1. <ins>Let _promiseCapability_ be _state_.[[PromiseCapability]].</ins>
          1. If _moduleCompletion_ is an abrupt completion, then
            1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _moduleCompletion_.[[Value]] &raquo;).
            1. Return ~unused~.
          1. Let _module_ be _moduleCompletion_.[[Value]].
          1. <ins>If _state_.[[Phase]] is ~source~, then</ins>
            1. <ins>Let _moduleSourceObject_ be Completion(_module_.GetModuleSource()).</ins>
            1. <ins>If _moduleSourceObject_ is an abrupt completion, then</ins>
              1. <ins>Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _moduleSourceObject_.[[Value]] &raquo;).</ins>
            1. <ins>Else,</ins>
              1. <ins>Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; _moduleSourceObject_.[[Value]] &raquo;).</ins>
            1. <ins>Return ~unused~.</ins>
          1. Let _loadPromise_ be _module_.LoadRequestedModules().
          1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_reason_) that captures _promiseCapability_ and performs the following steps when called:
            1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _reason_ &raquo;).
            1. Return ~unused~.
          1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 1, *""*, &laquo; &raquo;).
          1. Let _linkAndEvaluateClosure_ be a new Abstract Closure with no parameters that captures _module_, _promiseCapability_, and _onRejected_ and performs the following steps when called:
            1. Let _link_ be Completion(_module_.Link()).
            1. If _link_ is an abrupt completion, then
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _link_.[[Value]] &raquo;).
              1. Return ~unused~.
            1. Let _evaluatePromise_ be _module_.Evaluate().
            1. Let _fulfilledClosure_ be a new Abstract Closure with no parameters that captures _module_ and _promiseCapability_ and performs the following steps when called:
              1. Let _namespace_ be GetModuleNamespace(_module_).
              1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; _namespace_ &raquo;).
              1. Return ~unused~.
            1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, *""*, 0, &laquo; &raquo;).
            1. Perform PerformPromiseThen(_evaluatePromise_, _onFulfilled_, _onRejected_).
          1. Let _linkAndEvaluate_ be CreateBuiltinFunction(_linkAndEvaluateClosure_, *""*, 0, &laquo; &raquo;).
          1. Perform PerformPromiseThen(_loadPromise_, _linkAndEvaluate_, _onRejected_).
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-scripts-and-modules" number="16">
  <h1>ECMAScript Language: Scripts and Modules</h1>

  <emu-clause id="sec-modules">
    <h1>Modules</h1>

    <emu-clause id="sec-module-semantics">
      <h1>Module Semantics</h1>

      <emu-clause id="sec-modulerequest-record">
        <h1><ins>ModuleRequest Records</ins></h1>

        <p>A <dfn id="modulerequest-record" variants="ModuleRequest Records">ModuleRequest Record</dfn> represents the request to import a module up to a given phase. It consists of the following fields:</p>
        <emu-table id="table-modulerequest-record-fields" caption="ModuleRequest Record fields">
          <table>
            <tbody>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value Type
                </th>
                <th>
                  Meaning
                </th>
              </tr>
              <tr>
                <td>
                  [[Specifier]]
                </td>
                <td>
                  String
                </td>
                <td>
                  The module specifier
                </td>
              </tr>
              <tr>
                <td>
                  [[Phase]]
                </td>
                <td>
                  ~source~ or ~evaluation~
                </td>
                <td>
                  The target import phase
                </td>
              </tr>
            </tbody>
          </table>
        </emu-table>

        <emu-note type="editor">In general, this proposal replaces places where module specifiers are passed around with ModuleRequest Records. For example, several syntax-directed operations, such as ModuleRequests produce Lists of ModuleRequest Records rather than Lists of Strings which are interpreted as module specifiers. Some algorithms like ImportEntries and ImportEntriesForModule pass around ModuleRequest Records rather than Strings, in a way which doesn't require any particular textual change. Additionally, record fields in Cyclic Module Records and Source Text Module Records which contained Lists of Strings are replaced by Lists of ModuleRequest Records, as indicated above.</emu-note>
      </emu-clause>

      <emu-clause id="sec-static-semantics-modulerequests" type="sdo" number="3">
        <h1>
          Static Semantics: ModuleRequests ( ): a List of <del>Strings</del><ins>ModuleRequest Records</ins>
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItem</emu-grammar>
        <emu-alg>
          1. Return ModuleRequests of |ModuleItem|.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. Let <del>_moduleNames_</del><ins>_requests_</ins> be ModuleRequests of |ModuleItemList|.
          1. Let <del>_additionalNames_</del><ins>_additionalRequests_</ins> be ModuleRequests of |ModuleItem|.
          1. <del>For each String _name_ of _additionalNames_, do</del>
          1. <ins>For each ModuleRequest Record _mr_ of _additionalRequests_, do</ins>
            1. <ins>Let _found_ be *false*.</ins>
            1. <ins>For each ModuleRequest Record _mr2_ of _requests_, do</ins>
              1. <ins>If _mr_.[[Specifer]] is _mr2_.[[Specifer]] and _mr_.[[Phase]] is _mr2_.[[Phase]], then</ins>
                1. <ins>Assert: _found_ is *false*.</ins>
                1. <ins>Set _found_ to *true*.</ins>
            1. <del>If _moduleNames_ does not contain _name_, then</del>
            1. <ins>If _found_ is *false*, then</ins>
              1. Append <del>_name_</del><ins>_mr_</ins> to <del>_moduleNames_</del><ins>_requests_</ins>.
          1. Return <del>_moduleNames_</del><ins>_requests_</ins>.
        </emu-alg>
        <emu-grammar>ModuleItem : StatementListItem</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>
          ImportDeclaration : `import` ImportClause FromClause `;`
        </emu-grammar>
        <emu-alg>
          1. <del>Return ModuleRequests of |FromClause|.</del>
          1. <ins>Let _specifier_ be SV of |FromClause|.</ins>
          1. <ins>Return a List whose sole element is the ModuleRequest Record { [[Specifer]]: _specifier_, [[Phase]]: ~evaluation~ }.</ins>
        </emu-alg>
        <emu-grammar><ins>ImportDeclaration : `import` `source` ImportedBinding FromClause `;`</ins></emu-grammar>
        <emu-alg>
          1. <ins>Let _specifier_ be SV of |FromClause|.</ins>
          1. <ins>Return a List whose sole element is the ModuleRequest Record { [[Specifer]]: _specifier_, [[Phase]]: ~source~ }.</ins>
        </emu-alg>
        <emu-grammar><del>ModuleSpecifier : StringLiteral</del></emu-grammar>
        <emu-alg>
          1. <del>Return a List whose sole element is the SV of |StringLiteral|.</del>
        </emu-alg>
        <emu-grammar>
          ExportDeclaration : `export` ExportFromClause FromClause `;`
        </emu-grammar>
        <emu-alg>
          1. <del>Return ModuleRequests of |FromClause|.</del>
          1. <ins>Let _specifier_ be SV of |FromClause|.</ins>
          1. <ins>Return a List whose sole element is the ModuleRequest Record { [[Specifer]]: _specifier_, [[Phase]]: ~evaluation~ }.</ins>
        </emu-alg>
        <emu-grammar>
          ExportDeclaration :
            `export` NamedExports `;`
            `export` VariableStatement
            `export` Declaration
            `export` `default` HoistableDeclaration
            `export` `default` ClassDeclaration
            `export` `default` AssignmentExpression `;`
        </emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-modulesource-record">
        <h1><ins>ModuleSource Records</ins></h1>

        <p>A <dfn id="modulesource-record" variants="ModuleSource Records">ModuleSource Record</dfn> represents the request to import a module up to a given phase. It consists of the following fields:</p>
        <emu-table id="table-modulesource-record-fields" caption="ModuleSource Record fields">
          <table>
            <tbody>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value Type
                </th>
                <th>
                  Meaning
                </th>
              </tr>
              <tr>
                <td>
                  [[SourceClassName]]
                </td>
                <td>
                  String
                </td>
                <td>
                  The unique source class name string used to represent this module source. Source Text Module Records are usually represented by the *"ModuleSource"* class.
                </td>
              </tr>
              <tr>
                <td>
                  [[HostDefined]]
                </td>
                <td>
                  anything (default value is *undefined*)
                </td>
                <td>
                  Field reserved for use by host environments to associate additional information with module sources.
                </td>
              </tr>
            </tbody>
          </table>
        </emu-table>

        <emu-note type="editor">In general, this proposal replaces places where module specifiers are passed around with ModuleRequest Records. For example, several syntax-directed operations, such as ModuleRequests produce Lists of ModuleRequest Records rather than Lists of Strings which are interpreted as module specifiers. Some algorithms like ImportEntries and ImportEntriesForModule pass around ModuleRequest Records rather than Strings, in a way which doesn't require any particular textual change. Additionally, record fields in Cyclic Module Records and Source Text Module Records which contained Lists of Strings are replaced by Lists of ModuleRequest Records, as indicated above.</emu-note>
      </emu-clause>

      <emu-clause id="sec-abstract-module-records">
        <h1>Abstract Module Records</h1>
        <p>A <dfn variants="Module Records">Module Record</dfn> encapsulates structural information about the imports and exports of a single module. This information is used to link the imports and exports of sets of connected modules. A Module Record includes four fields that are only used when evaluating a module.</p>
        <p>For specification purposes Module Record values are values of the Record specification type and can be thought of as existing in a simple object-oriented hierarchy where Module Record is an abstract class with both abstract and concrete subclasses. This specification defines the abstract subclass named Cyclic Module Record and its concrete subclass named Source Text Module Record. Other specifications and implementations may define additional Module Record subclasses corresponding to alternative module definition facilities that they defined.</p>
        <p>Module Record defines the fields listed in <emu-xref href="#table-module-record-fields"></emu-xref>. All Module Definition subclasses include at least those fields. Module Record also defines the abstract method list in <emu-xref href="#table-abstract-methods-of-module-records"></emu-xref>. All Module definition subclasses must provide concrete implementations of these abstract methods.</p>
        <emu-table id="table-module-record-fields" caption="Module Record Fields" oldids="table-36">
          <table>
            <thead>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value Type
                </th>
                <th>
                  Meaning
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Realm]]
              </td>
              <td>
                a Realm Record
              </td>
              <td>
                The Realm within which this module was created.
              </td>
            </tr>
            <tr>
              <td>
                [[Environment]]
              </td>
              <td>
                a Module Environment Record or ~empty~
              </td>
              <td>
                The Environment Record containing the top level bindings for this module. This field is set when the module is linked.
              </td>
            </tr>
            <tr>
              <td>
                [[Namespace]]
              </td>
              <td>
                an Object or ~empty~
              </td>
              <td>
                The Module Namespace Object (<emu-xref href="#sec-module-namespace-objects"></emu-xref>) if one has been created for this module.
              </td>
            </tr>
            <tr>
              <td>
                [[HostDefined]]
              </td>
              <td>
                anything (default value is *undefined*)
              </td>
              <td>
                Field reserved for use by host environments that need to associate additional information with a module.
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-table id="table-abstract-methods-of-module-records" caption="Abstract Methods of Module Records" oldids="table-37">
          <table>
            <tr>
              <th>
                Method
              </th>
              <th>
                Purpose
              </th>
            </tr>
            <tr>
              <td>
                LoadRequestedModules( [ _hostDefined_ ] )
              </td>
              <td>
                <p>Prepares the module for linking by recursively loading all its dependencies, and returns a promise.</p>
              </td>
            </tr>
            <tr>
              <td>
                GetExportedNames([_exportStarSet_])
              </td>
              <td>
                <p>Return a list of all names that are either directly or indirectly exported from this module.</p>
                <p>LoadRequestedModules must have completed successfully prior to invoking this method.</p>
              </td>
            </tr>
            <tr>
              <td>
                ResolveExport(_exportName_ [, _resolveSet_])
              </td>
              <td>
                <p>Return the binding of a name exported by this module. Bindings are represented by a <dfn id="resolvedbinding-record" variants="ResolvedBinding Records">ResolvedBinding Record</dfn>, of the form { [[Module]]: Module Record, [[BindingName]]: String | ~namespace~ }. If the export is a Module Namespace Object without a direct binding in any module, [[BindingName]] will be set to ~namespace~. Return *null* if the name cannot be resolved, or ~ambiguous~ if multiple bindings were found.</p>
                <p>Each time this operation is called with a specific _exportName_, _resolveSet_ pair as arguments it must return the same result.</p>
                <p>LoadRequestedModules must have completed successfully prior to invoking this method.</p>
              </td>
            </tr>
            <tr>
              <td>
                Link()
              </td>
              <td>
                <p>Prepare the module for evaluation by transitively resolving all module dependencies and creating a Module Environment Record.</p>
                <p>LoadRequestedModules must have completed successfully prior to invoking this method.</p>
              </td>
            </tr>
            <tr>
              <td>
                Evaluate()
              </td>
              <td>
                <p>Returns a promise for the evaluation of this module and its dependencies, resolving on successful evaluation or if it has already been evaluated successfully, and rejecting for an evaluation error or if it has already been evaluated unsuccessfully. If the promise is rejected, hosts are expected to handle the promise rejection and rethrow the evaluation error.</p>
                <p>Link must have completed successfully prior to invoking this method.</p>
              </td>
            </tr>
            <tr>
              <td>
                <ins>GetModuleSource()</ins>
              </td>
              <td>
                <p><ins>It returns either a normal completion completion for the ModuleSource Object corresponding to this source Module Record's source phase (<emu-xref href="#sec-module-source-objects"></emu-xref>), or a throw completion.</ins></p>
                <ins>When called multiple times on the same Module Record, if GetModuleSource() returns a normal completion it must always return a normal completion containing the same object.</ins>
                <ins>The returned object should be a subclass of %AbstractModuleSource%, and it must have an internal slot [[ModuleSourceRecord]].</ins>
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-cyclic-module-records">
        <h1>Cyclic Module Records</h1>

        <p>A <dfn id="cyclic-module-record" variants="Cyclic Module Records">Cyclic Module Record</dfn> is used to represent information about a module that can participate in dependency cycles with other modules that are subclasses of the Cyclic Module Record type. Module Records that are not subclasses of the Cyclic Module Record type must not participate in dependency cycles with Source Text Module Records.</p>
        <p>In addition to the fields defined in <emu-xref href="#table-module-record-fields"></emu-xref> Cyclic Module Records have the additional fields listed in <emu-xref href="#table-cyclic-module-fields"></emu-xref></p>
        <emu-table id="table-cyclic-module-fields" caption="Additional Fields of Cyclic Module Records">
          <table>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[Status]]
              </td>
              <td>
                ~unlinked~, ~linking~, ~linked~, ~evaluating~, ~evaluating-async~, or ~evaluated~
              </td>
              <td>
                Initially ~unlinked~. Transitions to ~linking~, ~linked~, ~evaluating~, possibly ~evaluating-async~, ~evaluated~ (in that order) as the module progresses throughout its lifecycle. ~evaluating-async~ indicates this module is queued to execute on completion of its asynchronous dependencies or it is a module whose [[HasTLA]] field is *true* that has been executed and is pending top-level completion.
              </td>
            </tr>
            <tr>
              <td>
                [[EvaluationError]]
              </td>
              <td>
                a throw completion or ~empty~
              </td>
              <td>
                A throw completion representing the exception that occurred during evaluation. *undefined* if no exception occurred or if [[Status]] is not ~evaluated~.
              </td>
            </tr>
            <tr>
              <td>
                [[DFSIndex]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td>
                Auxiliary field used during Link and Evaluate only. If [[Status]] is ~linking~ or ~evaluating~, this non-negative number records the point at which the module was first visited during the depth-first traversal of the dependency graph.
              </td>
            </tr>
            <tr>
              <td>
                [[DFSAncestorIndex]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td>
                Auxiliary field used during Link and Evaluate only. If [[Status]] is ~linking~ or ~evaluating~, this is either the module's own [[DFSIndex]] or that of an "earlier" module in the same strongly connected component.
              </td>
            </tr>
            <tr>
              <td>
                [[RequestedModules]]
              </td>
              <td>
                a List of <del>Strings</del><ins>ModuleRequest Records</ins>
              </td>
              <td>
                A List of all the |ModuleSpecifier| strings used by the module represented by this record to request the importation of a module, <ins>along with their maximum associated phase (~source~ or ~evaluation~)</ins>. The List is in source text occurrence order.
              </td>
            </tr>
            <tr>
              <td>
                [[CycleRoot]]
              </td>
              <td>
                a Cyclic Module Record or ~empty~
              </td>
              <td>
                The first visited module of the cycle, the root DFS ancestor of the strongly connected component. For a module not in a cycle this would be the module itself. Once Evaluate has completed, a module's [[DFSAncestorIndex]] is equal to the [[DFSIndex]] of its [[CycleRoot]].
              </td>
            </tr>
            <tr>
              <td>
                [[HasTLA]]
              </td>
              <td>
                a Boolean
              </td>
              <td>
                Whether this module is individually asynchronous (for example, if it's a Source Text Module Record containing a top-level await). Having an asynchronous dependency does not mean this field is *true*. This field must not change after the module is parsed.
              </td>
            </tr>
            <tr>
              <td>
                [[AsyncEvaluation]]
              </td>
              <td>
                a Boolean
              </td>
              <td>
                Whether this module is either itself asynchronous or has an asynchronous dependency. Note: The order in which this field is set is used to order queued executions, see <emu-xref href="#sec-async-module-execution-fulfilled"></emu-xref>.
              </td>
            </tr>
            <tr>
              <td>
                [[TopLevelCapability]]
              </td>
              <td>
                a PromiseCapability Record or ~empty~
              </td>
              <td>
                If this module is the [[CycleRoot]] of some cycle, and Evaluate() was called on some module in that cycle, this field contains the PromiseCapability Record for that entire evaluation. It is used to settle the Promise object that is returned from the Evaluate() abstract method. This field will be ~empty~ for any dependencies of that module, unless a top-level Evaluate() has been initiated for some of those dependencies.
              </td>
            </tr>
            <tr>
              <td>
                [[AsyncParentModules]]
              </td>
              <td>
                a List of Cyclic Module Records
              </td>
              <td>
                If this module or a dependency has [[HasTLA]] *true*, and execution is in progress, this tracks the parent importers of this module for the top-level execution job. These parent modules will not start executing before this module has successfully completed execution.
              </td>
            </tr>
            <tr>
              <td>
                [[PendingAsyncDependencies]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td>
                If this module has any asynchronous dependencies, this tracks the number of asynchronous dependency modules remaining to execute for this module. A module with asynchronous dependencies will be executed when this field reaches 0 and there are no execution errors.
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-LoadRequestedModules" type="concrete method">
          <h1>
            LoadRequestedModules (
              optional _hostDefined_: anything,
            ): a Promise object
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Cyclic Module Record _module_</dd>
            <dt>description</dt>
            <dd>It populates the [[LoadedModules]] of all the Module Records in the dependency graph of _module_ (most of the work is done by the auxiliary function InnerModuleLoading). It takes an optional _hostDefined_ parameter that is passed to the HostLoadImportedModule hook.</dd>
          </dl>

          <emu-clause id="sec-InnerModuleLoading" type="abstract operation">
            <h1>
              InnerModuleLoading (
                _state_: a GraphLoadingState Record,
                _module_: a Module Record,
                <ins>_phase_: ~source~ or ~evaluation~,</ins>
              ): ~unused~
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used by LoadRequestedModules to recursively perform the actual loading process for _module_'s dependency graph.</dd>
            </dl>

            <emu-alg>
              1. Assert: _state_.[[IsLoading]] is *true*.
              1. If _module_ is a Cyclic Module Record, _module_.[[Status]] is ~new~, <del>and</del> _state_.[[Visited]] does not contain _module_<ins>, and _phase_ is ~evaluation~, </ins>then
                1. Append _module_ to _state_.[[Visited]].
                1. Let _requestedModulesCount_ be the number of elements in _module_.[[RequestedModules]].
                1. Set _state_.[[PendingModulesCount]] to _state_.[[PendingModulesCount]] + _requestedModulesCount_.
                1. <del>For each String _required_ of _module_.[[RequestedModules]], do</del>
                1. <ins>For each ModuleRequest Record _required_ of _module_.[[RequestedModules]], do</ins>
                  1. If _module_.[[LoadedModules]] contains a Record whose [[Specifier]] is _required_<ins>.[[Specifier]]</ins>, then
                    1. Let _record_ be that Record.
                    1. Perform InnerModuleLoading(_state_, _record_.[[Module]], <ins>_required_.[[Phase]]</ins>).
                  1. Else,
                    1. Perform HostLoadImportedModule(_module_, _required_, _state_.[[HostDefined]], _state_).
                    1. NOTE: HostLoadImportedModule will call FinishLoadingImportedModule, which re-enters the graph loading process through ContinueModuleLoading.
                  1. If _state_.[[IsLoading]] is *false*, return ~unused~.
              1. Assert: _state_.[[PendingModulesCount]] ‚â• 1.
              1. Set _state_.[[PendingModulesCount]] to _state_.[[PendingModulesCount]] - 1.
              1. If _state_.[[PendingModulesCount]] = 0, then
                1. Set _state_.[[IsLoading]] to *false*.
                1. For each Cyclic Module Record _loaded_ of _state_.[[Visited]], do
                  1. If _loaded_.[[Status]] is ~new~, set _loaded_.[[Status]] to ~unlinked~.
                1. Perform ! Call(_state_.[[PromiseCapability]].[[Resolve]], *undefined*, ¬´ *undefined* ¬ª).
              1. Return ~unused~.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-ContinueModuleLoading" type="abstract operation">
            <h1>
              ContinueModuleLoading (
                _state_: a GraphLoadingState Record,
                <ins>_referrer_: a Cyclic Module Record,</ins>
                <ins>_specifier_: a String,</ins>
                _moduleCompletion_: either a normal completion containing a Module Record or a throw completion,
              ): ~unused~
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used to re-enter the loading process after a call to HostLoadImportedModule.</dd>
            </dl>

            <emu-alg>
              1. If _state_.[[IsLoading]] is *false*, return ~unused~.
              1. If _moduleCompletion_ is a normal completion, then
                1. <ins>Let _phase_ be ~source~.</ins>
                1. <ins>If _referrer_.[[RequestedModules]] contains a ModuleRequest Record whose [[Specifer]] is _specifier_ and whose [[Phase]] is ~evaluation~, then</ins>
                  1. <ins>Set _phase_ to ~evaluation~.</ins>
                1. Perform InnerModuleLoading(_state_, _moduleCompletion_.[[Value]]<ins>, _phase_</ins>).
              1. Else,
                1. Set _state_.[[IsLoading]] to *false*.
                1. Perform ! Call(_state_.[[PromiseCapability]].[[Reject]], *undefined*, ¬´ _moduleCompletion_.[[Value]] ¬ª).
              1. Return ~unused~.
            </emu-alg>
          </emu-clause>
        </emu-clause>

        <emu-clause id="sec-moduledeclarationlinking" type="concrete method" oldids="sec-moduledeclarationinstantiation">
          <h1>Link ( ): either a normal completion containing ~unused~ or a throw completion</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Cyclic Module Record _module_</dd>

            <dt>description</dt>
            <dd>On success, Link transitions this module's [[Status]] from ~unlinked~ to ~linked~. On failure, an exception is thrown and this module's [[Status]] remains ~unlinked~. (Most of the work is done by the auxiliary function InnerModuleLinking.)</dd>
          </dl>

          <emu-clause id="sec-InnerModuleLinking" type="abstract operation" oldids="sec-innermoduleinstantiation">
            <h1>
              InnerModuleLinking (
                _module_: a Module Record,
                _stack_: a List of Cyclic Module Records,
                _index_: a non-negative integer,
              ): either a normal completion containing a non-negative integer or a throw completion
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used by Link to perform the actual linking process for _module_, as well as recursively on all other modules in the dependency graph. The _stack_ and _index_ parameters, as well as a module's [[DFSIndex]] and [[DFSAncestorIndex]] fields, keep track of the depth-first search (DFS) traversal. In particular, [[DFSAncestorIndex]] is used to discover strongly connected components (SCCs), such that all modules in an SCC transition to ~linked~ together.</dd>
            </dl>

            <emu-alg>
              1. If _module_ is not a Cyclic Module Record, then
                1. Perform ? _module_.Link().
                1. Return _index_.
              1. If _module_.[[Status]] is one of ~linking~, ~linked~, ~evaluating-async~, or ~evaluated~, then
                1. Return _index_.
              1. Assert: _module_.[[Status]] is ~unlinked~.
              1. Set _module_.[[Status]] to ~linking~.
              1. Set _module_.[[DFSIndex]] to _index_.
              1. Set _module_.[[DFSAncestorIndex]] to _index_.
              1. Set _index_ to _index_ + 1.
              1. Append _module_ to _stack_.
              1. For each <del>String</del><ins>ModuleRequest Record</ins> _required_ of _module_.[[RequestedModules]], do
                1. <ins>If _required_.[[Phase]] is ~evaluation~, then</ins>
                  1. Let _requiredModule_ be GetImportedModule(_module_, _required_<ins>.[[Specifier]]</ins>).
                  1. Set _index_ to ? InnerModuleLinking(_requiredModule_, _stack_, _index_).
                  1. If _requiredModule_ is a Cyclic Module Record, then
                    1. Assert: _requiredModule_.[[Status]] is one of ~linking~, ~linked~, ~evaluating-async~, or ~evaluated~.
                    1. Assert: _requiredModule_.[[Status]] is ~linking~ if and only if _stack_ contains _requiredModule_.
                    1. If _requiredModule_.[[Status]] is ~linking~, then
                      1. Set _module_.[[DFSAncestorIndex]] to min(_module_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]).
              1. Perform ? _module_.InitializeEnvironment().
              1. Assert: _module_ occurs exactly once in _stack_.
              1. Assert: _module_.[[DFSAncestorIndex]] ‚â§ _module_.[[DFSIndex]].
              1. If _module_.[[DFSAncestorIndex]] = _module_.[[DFSIndex]], then
                1. Let _done_ be *false*.
                1. Repeat, while _done_ is *false*,
                  1. Let _requiredModule_ be the last element of _stack_.
                  1. Remove the last element of _stack_.
                  1. Assert: _requiredModule_ is a Cyclic Module Record.
                  1. Set _requiredModule_.[[Status]] to ~linked~.
                  1. If _requiredModule_ and _module_ are the same Module Record, set _done_ to *true*.
              1. Return _index_.
            </emu-alg>
          </emu-clause>
        </emu-clause>
        <emu-clause id="sec-moduleevaluation" type="concrete method">
          <h1>Evaluate ( ): a Promise</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Cyclic Module Record _module_</dd>

            <dt>description</dt>
            <dd>Evaluate transitions this module's [[Status]] from ~linked~ to either ~evaluating-async~ or ~evaluated~. The first time it is called on a module in a given strongly connected component, Evaluate creates and returns a Promise which resolves when the module has finished evaluating. This Promise is stored in the [[TopLevelCapability]] field of the [[CycleRoot]] for the component. Future invocations of Evaluate on any module in the component return the same Promise. (Most of the work is done by the auxiliary function InnerModuleEvaluation.)</dd>
          </dl>

          <emu-clause id="sec-innermoduleevaluation" type="abstract operation">
            <h1>
              InnerModuleEvaluation (
                _module_: a Module Record,
                _stack_: a List of Cyclic Module Records,
                _index_: a non-negative integer,
              ): either a normal completion containing a non-negative integer or a throw completion
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used by Evaluate to perform the actual evaluation process for _module_, as well as recursively on all other modules in the dependency graph. The _stack_ and _index_ parameters, as well as _module_'s [[DFSIndex]] and [[DFSAncestorIndex]] fields, are used the same way as in InnerModuleLinking.</dd>
            </dl>

            <emu-alg>
              1. If _module_ is not a Cyclic Module Record, then
                1. Let _promise_ be ! _module_.Evaluate().
                1. Assert: _promise_.[[PromiseState]] is not ~pending~.
                1. If _promise_.[[PromiseState]] is ~rejected~, then
                  1. Return ThrowCompletion(_promise_.[[PromiseResult]]).
                1. Return _index_.
              1. If _module_.[[Status]] is either ~evaluating-async~ or ~evaluated~, then
                1. If _module_.[[EvaluationError]] is ~empty~, return _index_.
                1. Otherwise, return ? _module_.[[EvaluationError]].
              1. If _module_.[[Status]] is ~evaluating~, return _index_.
              1. Assert: _module_.[[Status]] is ~linked~.
              1. Set _module_.[[Status]] to ~evaluating~.
              1. Set _module_.[[DFSIndex]] to _index_.
              1. Set _module_.[[DFSAncestorIndex]] to _index_.
              1. Set _module_.[[PendingAsyncDependencies]] to 0.
              1. Set _index_ to _index_ + 1.
              1. Append _module_ to _stack_.
              1. <del>For each String _required_ of _module_.[[RequestedModules]], do</del>
              1. <ins>For each ModuleRequest Record _required_ of _module_.[[RequestedModules]], do</ins>
                1. Let _requiredModule_ be GetImportedModule(_module_, _required_<ins>.[[Specifier]]</ins>).
                1. <ins>If _requiredModule_.[[Phase]] is ~evaluation~, then</ins>
                  1. Set _index_ to ? InnerModuleEvaluation(_requiredModule_, _stack_, _index_).
                  1. If _requiredModule_ is a Cyclic Module Record, then
                    1. Assert: _requiredModule_.[[Status]] is one of ~evaluating~, ~evaluating-async~, or ~evaluated~.
                    1. Assert: _requiredModule_.[[Status]] is ~evaluating~ if and only if _stack_ contains _requiredModule_.
                    1. If _requiredModule_.[[Status]] is ~evaluating~, then
                      1. Set _module_.[[DFSAncestorIndex]] to min(_module_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]).
                    1. Else,
                      1. Set _requiredModule_ to _requiredModule_.[[CycleRoot]].
                      1. Assert: _requiredModule_.[[Status]] is either ~evaluating-async~ or ~evaluated~.
                      1. If _requiredModule_.[[EvaluationError]] is not ~empty~, return ? _requiredModule_.[[EvaluationError]].
                    1. If _requiredModule_.[[AsyncEvaluation]] is *true*, then
                      1. Set _module_.[[PendingAsyncDependencies]] to _module_.[[PendingAsyncDependencies]] + 1.
                      1. Append _module_ to _requiredModule_.[[AsyncParentModules]].
              1. If _module_.[[PendingAsyncDependencies]] > 0 or _module_.[[HasTLA]] is *true*, then
                1. Assert: _module_.[[AsyncEvaluation]] is *false* and was never previously set to *true*.
                1. Set _module_.[[AsyncEvaluation]] to *true*.
                1. NOTE: The order in which module records have their [[AsyncEvaluation]] fields transition to *true* is significant. (See <emu-xref href="#sec-async-module-execution-fulfilled"></emu-xref>.)
                1. If _module_.[[PendingAsyncDependencies]] = 0, perform ExecuteAsyncModule(_module_).
              1. Else,
                1. Perform ? <emu-meta effects="user-code">_module_.ExecuteModule()</emu-meta>.
              1. Assert: _module_ occurs exactly once in _stack_.
              1. Assert: _module_.[[DFSAncestorIndex]] ‚â§ _module_.[[DFSIndex]].
              1. If _module_.[[DFSAncestorIndex]] = _module_.[[DFSIndex]], then
                1. Let _done_ be *false*.
                1. Repeat, while _done_ is *false*,
                  1. Let _requiredModule_ be the last element of _stack_.
                  1. Remove the last element of _stack_.
                  1. Assert: _requiredModule_ is a Cyclic Module Record.
                  1. If _requiredModule_.[[AsyncEvaluation]] is *false*, set _requiredModule_.[[Status]] to ~evaluated~.
                  1. Otherwise, set _requiredModule_.[[Status]] to ~evaluating-async~.
                  1. If _requiredModule_ and _module_ are the same Module Record, set _done_ to *true*.
                  1. Set _requiredModule_.[[CycleRoot]] to _module_.
              1. Return _index_.
            </emu-alg>
          </emu-clause>
        </emu-clause>
        <emu-clause id="sec-getmodulesource" type="concrete method">
          <h1>
            <ins>
              GetModuleSource ( ): either a normal completion containing an Object or a throw completion
            </ins>
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Cyclic Module Record _module_</dd>

            <dt>description</dt>
            <dd>
              <p>Cyclic Module Record provides a default GetModuleSource implementation with an abrupt completion to provide a standard reference error that a source phase import is not available.</p>
            </dd>
          </dl>
          <emu-alg>
            1. Let _error_ be a newly created *ReferenceError* object.
            1. Return ThrowCompletion(_error_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-source-text-module-records">
        <h1>Source Text Module Records</h1>

        <emu-clause id="sec-source-text-module-record-initialize-environment" type="concrete method">
          <h1>InitializeEnvironment ( ): either a normal completion containing ~unused~ or a throw completion</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Source Text Module Record _module_</dd>
          </dl>

          <emu-alg>
            1. For each ExportEntry Record _e_ of _module_.[[IndirectExportEntries]], do
              1. Let _resolution_ be _module_.ResolveExport(_e_.[[ExportName]]).
              1. If _resolution_ is either *null* or ~ambiguous~, throw a *SyntaxError* exception.
              1. Assert: _resolution_ is a ResolvedBinding Record.
            1. Assert: All named exports from _module_ are resolvable.
            1. Let _realm_ be _module_.[[Realm]].
            1. Assert: _realm_ is not *undefined*.
            1. Let _env_ be NewModuleEnvironment(_realm_.[[GlobalEnv]]).
            1. Set _module_.[[Environment]] to _env_.
            1. For each ImportEntry Record _in_ of _module_.[[ImportEntries]], do
              1. Let _importedModule_ be GetImportedModule(_module_, _in_.[[ModuleRequest]]).
              1. If _in_.[[ImportName]] is ~namespace-object~, then
                1. Let _namespace_ be GetModuleNamespace(_importedModule_).
                1. Perform ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).
                1. Perform ! _env_.InitializeBinding(_in_.[[LocalName]], _namespace_).
              1. <ins>Else if _in_.[[ImportName]] is ~source~, then</ins>
                1. <ins>Let _moduleSourceObject_ be ? _importedModule_.GetModuleSource().</ins>
                1. <ins>Perform ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).</ins>
                1. <ins>Perform ! _env_.InitializeBinding(_in_.[[LocalName]], _moduleSourceObject_).</ins>
              1. Else,
                1. Let _resolution_ be _importedModule_.ResolveExport(_in_.[[ImportName]]).
                1. If _resolution_ is either *null* or ~ambiguous~, throw a *SyntaxError* exception.
                1. If _resolution_.[[BindingName]] is ~namespace~, then
                  1. Let _namespace_ be GetModuleNamespace(_resolution_.[[Module]]).
                  1. Perform ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).
                  1. Perform ! _env_.InitializeBinding(_in_.[[LocalName]], _namespace_).
                1. Else,
                  1. Perform _env_.CreateImportBinding(_in_.[[LocalName]], _resolution_.[[Module]], _resolution_.[[BindingName]]).
            1. Let _moduleContext_ be a new ECMAScript code execution context.
            1. Set the Function of _moduleContext_ to *null*.
            1. Assert: _module_.[[Realm]] is not *undefined*.
            1. Set the Realm of _moduleContext_ to _module_.[[Realm]].
            1. Set the ScriptOrModule of _moduleContext_ to _module_.
            1. Set the VariableEnvironment of _moduleContext_ to _module_.[[Environment]].
            1. Set the LexicalEnvironment of _moduleContext_ to _module_.[[Environment]].
            1. Set the PrivateEnvironment of _moduleContext_ to *null*.
            1. Set _module_.[[Context]] to _moduleContext_.
            1. Push _moduleContext_ onto the execution context stack; _moduleContext_ is now the running execution context.
            1. Let _code_ be _module_.[[ECMAScriptCode]].
            1. Let _varDeclarations_ be the VarScopedDeclarations of _code_.
            1. Let _declaredVarNames_ be a new empty List.
            1. For each element _d_ of _varDeclarations_, do
              1. For each element _dn_ of the BoundNames of _d_, do
                1. If _declaredVarNames_ does not contain _dn_, then
                  1. Perform ! _env_.CreateMutableBinding(_dn_, *false*).
                  1. Perform ! _env_.InitializeBinding(_dn_, *undefined*).
                  1. Append _dn_ to _declaredVarNames_.
            1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _code_.
            1. Let _privateEnv_ be *null*.
            1. For each element _d_ of _lexDeclarations_, do
              1. For each element _dn_ of the BoundNames of _d_, do
                1. If IsConstantDeclaration of _d_ is *true*, then
                  1. Perform ! _env_.CreateImmutableBinding(_dn_, *true*).
                1. Else,
                  1. Perform ! _env_.CreateMutableBinding(_dn_, *false*).
                1. If _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|, then
                  1. Let _fo_ be InstantiateFunctionObject of _d_ with arguments _env_ and _privateEnv_.
                  1. Perform ! _env_.InitializeBinding(_dn_, _fo_).
            1. Remove _moduleContext_ from the execution context stack.
            1. Return ~unused~.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-HostLoadImportedModule" type="host-defined abstract operation">
        <h1>
          HostLoadImportedModule (
            _referrer_: a Script Record, a Cyclic Module Record, or a Realm Record,
            <del>_specifier_: a String,</del>
            <ins>_moduleRequest_: a ModuleRequest Record,</ins>
            _hostDefined_: anything,
            _payload_: a GraphLoadingState Record or a <del>PromiseCapability Record</del><ins>DynamicImportState Record</ins>,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>

        <emu-note id="note-HostLoadImportedModule-referrer-Realm-Record">
          <p>An example of when _referrer_ can be a Realm Record is in a web browser host. There, if a user clicks on a control given by</p>

          <pre><code class="html">&lt;button type="button" onclick="import('./foo.mjs')"&gt;Click me&lt;/button&gt;</code></pre>

          <p>there will be no active script or module at the time the <emu-xref href="#sec-import-calls">`import()`</emu-xref> expression runs. More generally, this can happen in any situation where the host pushes execution contexts with *null* ScriptOrModule components onto the execution context stack.</p>
        </emu-note>

        <p>An implementation of HostLoadImportedModule must conform to the following requirements:</p>
        <ul>
          <li>
            The host environment must perform FinishLoadingImportedModule(_referrer_, <del>_specifier_</del><ins>_moduleRequest_.[[Specifier]]</ins>, _payload_, _result_), where _result_ is either a normal completion containing the loaded Module Record or a throw completion, either synchronously or asynchronously.
          </li>
          <li>
            If this operation is called multiple times with the same (_referrer_, <del>_specifier_</del><ins>_moduleRequest_.[[Specifier]]</ins>) pair and it performs FinishLoadingImportedModule(_referrer_, <del>_specifier_</del><ins>_moduleRequest_.[[Specifier]]</ins>, _payload_, _result_) where _result_ is a normal completion, then it must perform FinishLoadingImportedModule(_referrer_, <del>_specifier_</del><ins>_moduleRequest_.[[Specifier]]</ins>, _payload_, _result_) with the same _result_ each time.
          </li>
          <li>
            <ins>The completion record returned by this operation must not be affected by _moduleRequest_.[[Phase]].</ins>
          </li>
          <li>
            The operation must treat _payload_ as an opaque value to be passed through to FinishLoadingImportedModule.
          </li>
        </ul>

        <p>The actual process performed is host-defined, but typically consists of performing whatever I/O operations are necessary to load the appropriate Module Record. Multiple different (_referrer_, <del>_specifier_</del><ins>_moduleRequest_.[[Specifier]]</ins>) pairs may map to the same Module Record instance. The actual mapping semantics is host-defined but typically a normalization process is applied to _specifier_ as part of the mapping process. A typical normalization process would include actions such as expansion of relative and abbreviated path specifiers.</p>

        <emu-note>
          <p><ins><emu-xref href="#sec-hosts-and-implementations">Implementations</emu-xref> may provide unobservable module loading optimizations, such as speculative preloading of modules that are likely to be requested next. When doing so, they should consider whether the module is being imported for its ~source~ phase, which won't cause calls to the HostLoadImportedModule hook for its transitive dependencies, or for its ~evaluation~ phase.</ins></p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-FinishLoadingImportedModule" type="abstract operation">
        <h1>
          FinishLoadingImportedModule (
            _referrer_: a Script Record, a Cyclic Module Record, or a Realm Record,
            _specifier_: a String,
            _payload_: a GraphLoadingState Record or a <del>PromiseCapability Record</del><ins>DynamicImportState Record</ins>,
            _result_: either a normal completion containing a Module Record or a throw completion,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>
        <emu-alg>
          1. If _result_ is a normal completion, then
            1. If _referrer_.[[LoadedModules]] contains a Record _record_ such that _record_.[[Specifier]] is _specifier_, then
              1. Assert: _record_.[[Module]] is _result_.[[Value]].
            1. Else, append the Record { [[Specifier]]: _specifier_, [[Module]]: _result_.[[Value]] } to _referrer_.[[LoadedModules]].
          1. If _payload_ is a GraphLoadingState Record, then
            1. Perform ContinueModuleLoading(_payload_, <ins>_referrer_, _specifier_,</ins> _result_).
          1. Else,
            1. Perform ContinueDynamicImport(_payload_, _result_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-imports">
    <h1>Imports</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ImportDeclaration :
        `import` ImportClause FromClause `;`
        `import` ModuleSpecifier `;`
        <ins>`import` `source` ImportedBinding FromClause `;`</ins>

      ImportClause :
        ImportedDefaultBinding
        NameSpaceImport
        NamedImports
        ImportedDefaultBinding `,` NameSpaceImport
        ImportedDefaultBinding `,` NamedImports
  
      ImportedDefaultBinding :
        ImportedBinding
  
      NameSpaceImport :
        `*` `as` ImportedBinding
  
      NamedImports :
        `{` `}`
        `{` ImportsList `}`
        `{` ImportsList `,` `}`
  
      FromClause :
        `from` ModuleSpecifier
  
      ImportsList :
        ImportSpecifier
        ImportsList `,` ImportSpecifier
  
      ImportSpecifier :
        ImportedBinding
        ModuleExportName `as` ImportedBinding
  
      ModuleSpecifier :
        StringLiteral
  
      ImportedBinding :
        BindingIdentifier[~Yield, +Await]
    </emu-grammar>

    <emu-clause id="sec-static-semantics-importentries" oldids="sec-module-semantics-static-semantics-importentries,sec-imports-static-semantics-importentries" type="syntax-directed operation">
      <h1>Static Semantics: ImportEntries ( ): a List of ImportEntry Records</h1>
      <dl class="header">
      </dl>
      <emu-grammar>Module : [empty]</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. Let _entries1_ be ImportEntries of |ModuleItemList|.
        1. Let _entries2_ be ImportEntries of |ModuleItem|.
        1. Return the list-concatenation of _entries1_ and _entries2_.
      </emu-alg>
      <emu-grammar>
        ModuleItem :
          ExportDeclaration
          StatementListItem
      </emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>ImportDeclaration : `import` ImportClause FromClause `;`</emu-grammar>
      <emu-alg>
        1. Let _module_ be the sole element of ModuleRequests of |FromClause|.
        1. Return ImportEntriesForModule of |ImportClause| with argument _module_.
      </emu-alg>
      <emu-grammar>ImportDeclaration : `import` ModuleSpecifier `;`</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar><ins>ImportDeclaration : `import` `source` ImportedBinding FromClause `;`</ins></emu-grammar>
      <emu-alg>
        1. <ins>Let _localName_ be the sole element of BoundNames of |ImportedBinding|.</ins>
        1. <ins>Let _entry_ be the ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: ~source~, [[LocalName]]: _localName_ }.</ins>
        1. <ins>Return ¬´ _entry_ ¬ª</ins>.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-reflection" number="28">
  <h1>Reflection</h1>
  <emu-clause id="sec-module-source-objects">
    <h1><ins>Module Source Objects</ins></h1>
    <p>Module Source Objects represent modules in their source import phase, which are not linked, instantiated or executed.</p>
    <p>All Module Source Objects should have a prototype of %AbstractModuleSource%.prototype and define a [[ModuleSourceRecord]] internal slot.</p>
    <p>Hosts may define their own Module Source subclasses for custom module record types.</p>

    <emu-clause id="sec-%abstractmodulesource%-constructor">
      <h1>The %AbstractModuleSource% Constructor</h1>
      <p>The %AbstractModuleSource% constructor:</p>
      <ul>
        <li>is <dfn>%AbstractModuleSource%</dfn>.</li>
        <li>along with its corresponding prototype object, provides common properties that are inherited by module source constructors and their instances.</li>
        <li>does not have a global name or appear as a property of the global object.</li>
        <li>acts as the abstract superclass of the _ModuleSource_ constructor.</li>
        <li>will throw an error when invoked, because it is an abstract class constructor. The module source constructors do not perform a `super` call to it.</li>
      </ul>

      <emu-clause id="sec-%abstractmodulesource%">
        <h1>%AbstractModuleSource% ( )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Throw a *TypeError* exception.
        </emu-alg>
        <p>The *"length"* property of this function is *+0*<sub>ùîΩ</sub>.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-%abstractmodulesource%-intrinsic-object">
      <h1>Properties of the %AbstractModuleSource% Intrinsic Object</h1>
      <p>The %AbstractModuleSource% intrinsic object:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has a *"name"* property whose value is *"AbstractModuleSource"*.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-%abstractmodulesource%.prototype">
        <h1>%AbstractModuleSource%.prototype</h1>
        <p>The initial value of %AbstractModuleSource%`.prototype` is the %AbstractModuleSource% prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-%abstractmodulesource%-prototype-object">
      <h1>Properties of the %AbstractModuleSource% Prototype Object</h1>
      <p>The <dfn>%AbstractModuleSource% prototype object</dfn>:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is <dfn>%AbstractModuleSource.prototype%</dfn>.</li>
        <li>is an ordinary object.</li>
        <li>does not have a global name or appear as a property of the global object.</li>
        <li>does not have a [[ModuleSourceRecord]] slot that is specific to _AbstractModuleSource_ and _AbstractModuleSource_ subclass instance objects.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-%abstractmodulesource%.prototype.constructor">
        <h1>%AbstractModuleSource%.prototype.constructor</h1>
        <p>The initial value of %AbstractModuleSource%`.prototype.constructor` is %AbstractModuleSource%.</p>
      </emu-clause>

      <emu-clause id="sec-get-%abstractmodulesource%.prototype.@@tostringtag">
        <h1>get %AbstractModuleSource%.prototype [ @@toStringTag ]</h1>
        <p>%AbstractModuleSource%.prototype `[@@toStringTag]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If _O_ is not an Object, return *undefined*.
          1. If _O_ does not have a [[ModuleSourceRecord]] internal slot, return *undefined*.
          1. Let _name_ be _O_.[[ModuleSourceRecord]].[[SourceClassName]]
          1. Assert: _name_ is a String.
          1. Return _name_.
        </emu-alg>
        <p>This property has the attributes { [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        <p>The initial value of the *"name"* property of this function is *"get [Symbol.toStringTag]"*.</p>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-annex id="sec-host-layering-points">
  <h1>Host Layering Points</h1>

  <emu-annex id="sec-host-defined-fields-summary">
    <h1>Host-defined Fields</h1>
    <p>[[HostDefined]] on Realm Records: See <emu-xref href="#table-realm-record-fields"></emu-xref>.</p>
    <p>[[HostDefined]] on Script Records: See <emu-xref href="#table-script-records"></emu-xref>.</p>
    <p>[[HostDefined]] on Module Records: See <emu-xref href="#table-module-record-fields"></emu-xref>.</p>
    <p><ins>[[HostDefined]] on ModuleSource Records: See <emu-xref href="#table-modulesource-record-fields"></emu-xref>.</ins></p>
    <p>[[HostDefined]] on JobCallback Records: See <emu-xref href="#table-jobcallback-records"></emu-xref>.</p>
    <p>[[HostSynchronizesWith]] on Candidate Executions: See <emu-xref href="#table-candidate-execution-records"></emu-xref>.</p>
    <p>[[IsHTMLDDA]]: See <emu-xref href="#sec-IsHTMLDDA-internal-slot"></emu-xref>.</p>
  </emu-annex>
</emu-annex>
